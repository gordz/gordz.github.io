<!DOCTYPE html>
<html>
    <head>
        <title>Start Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
    	<header><h1>Header section</h1></header>
        <canvas id="canvas" width="1000" height="1000">
        </canvas>
        
        <script type="text/javascript">
        	/**
        	* Library to assist with trigonometry related functions.
        	**/
        	var Trig = {
        		toDegrees: function(radians) {
            		// 2 PI rads = 360 degrees
            		// 1 rad = 180 / PI degrees
            		return radians * (180 / Math.PI);
        		},
        		
        		toRadians: function(degrees) {
            		// 360 degrees = 2 PI radians
            		// 1 degree = PI / 180 radians
            		return degrees * (Math.PI / 180);
        		},
        		
        		hypot: function() {
        			var sumOfSquares = 0;
        			for (i = 0; i < arguments.length; i++) {
        				var square = Math.pow(arguments[i], 2);
        				sumOfSquares += square;
        			}
        			return Math.sqrt(sumOfSquares);
        		}
         	}
        	
        	
        
        	var drawGrid = function(strokeStyle) {
    			const spacing = 20;
        		this.stokeStyle = strokeStyle;
        		
        		// Draw y axis.
        		this.beginPath();
        		for (i = 0; i < canvas.width / spacing; i++) {
        			// Move drawing cursor to x,y.
        			this.moveTo(0 + (i * spacing), 0);
        			// Draw line to x, y
        			this.lineTo(0 + (i * spacing), this.canvas.height);
        		}
        		
        		// Draw x axis
        		for (i = 0; i < canvas.height / spacing; i++) {
        			// Move drawing cursor to x,y.
        			this.moveTo(0, 0 + (i * spacing));
        			// Draw line to x, y
        			this.lineTo(this.canvas.width, 0 + (i * spacing));
        		}
     			this.stroke();
    			this.closePath();
        	}
        	
        	
        	function randomInteger(min, max) {
        		return min + Math.floor((max - min) * Math.random());
        	}

        	function drawHorizontalRandomJagged(context, minY, maxY, minPoints, maxPoints) {
        		var numPoints = randomInteger(minPoints, maxPoints);
        		console.log("numPoints: " + numPoints);
        		
        		// Generate random points.
        		var points = [];
            	for (i = 0; i < numPoints; i++) {
        			var x = Math.ceil(Math.random() * context.canvas.width);
        			var y = randomInteger(minY, maxY);
        			points.push({ x: x, y: y});
        		}
            	
            	// Sort by x co-ordinate.
        		points.sort(function(a, b) { 
        			return a.x - b.x;
        		});
          		
          		// Start at x = 0	
          		context.beginPath();
    			context.moveTo(0, randomInteger(minY, maxY));
    			points.forEach(function(point) {
    				context.lineTo(Number.toInteger(point.x), Number.toInteger(point.y));
    			});
    			// Finish at x = canvas width.
        		context.lineTo(context.canvas.width, randomInteger(minY, maxY));
        		
        		// Close to form polygon.
				context.lineTo(context.canvas.width, context.canvas.height);
        		context.lineTo(0, context.canvas.height);
        		context.closePath();
        		
        		// Fill with a gradient.
        		var gradient = context.createLinearGradient(0, minY, 0, context.canvas.height);
        		gradient.addColorStop(0, '#009900')
        		gradient.addColorStop(0.25, '#336600');
        		gradient.addColorStop(0.50, '#7A5229');
        		gradient.addColorStop(0.75,'#493119');
   				context.fillStyle = gradient;
        		context.fill();
        	}
        	
        	function drawSky(context) {
        		context.fillStyle = "#0099FF";	//sky blue.
        		context.fillRect(0, 0, context.canvas.width, context.canvas.height);
        	}
        	
        	function drawGround(context) {
        		drawHorizontalRandomJagged(context, 600, 940, 40, 50);
        	}
        	
        	
        	var drawRandomJagged = function(minX, minY, maxX, maxY) {
        		//this.strokeStyle = "blue";
        		///this.beginPath();
        		
        		var points = Math.floor(10 + (Math.random() * 10));
        		
        		//this.moveTo(0, 300);
        		var randomPoints = [];
        		for (i = 0; i < points; i++) {
        			var randX = minX + Math.floor(((maxX - minX) * Math.random()));
        			var randY = minY + Math.floor(((maxY - minY) * Math.random()));
        			randomPoints.push({x: randX, y: randY});
        		}    		
        		console.log(randomPoints);
        	}
   
        	// Draw a 3 colour flag.
        	var drawFlag = function(x, y, colour1, colour2, colour3) {
        		this.fillStyle = colour1;
        		this.fillRect(x, y, 20, 80);
        		
        		this.fillStyle = colour2;
        		this.fillRect(x + 20, y, 20, 80);
        		
        		this.fillStyle = colour3;
        		this.fillRect(x + 40, y, 20, 80);
        	}
        	
        	

        	var canvas = document.getElementById("canvas");
        	
        	// Get a CanvasRenderingContext2D.
        	var context = canvas.getContext("2d");

        	drawSky(context);
        	drawGround(context);
        	
        	// Draw a rectangle.
        	//context.fillStyle = "black";
        	// X, Y, width, height
        	//context.fillRect (1,9,400,400);
        	canvas.onclick = function(event) {
        		fireBullet(event);
        	}
        	
        	
        	var explosions = [];
        	
        	function fireBullet(event) {
        		var x = event.clientX - canvas.offsetLeft;
        		var y = event.clientY - canvas.offsetTop;
        		
        	    y += document.documentElement.scrollTop;
        	    
        		context.beginPath();
        		context.moveTo(0, 400);
        		context.lineTo(x, y);
        		context.stroke();
        		
        		// Draw explosion
        		explosions.push(new Explosion({x: x, y: y}));
        	}

        	function Explosion(centre) {
        		var speed = 50;
        		var maxRadius = 60;
        		var centre = centre;
        		var startTime = new Date().getTime();
        		var radius = 0;
        		var alive = true;
        		
        		this.updatePosition = function(time) {
        			        			
        			var elapsed = time - startTime;
        			//console.log("Time: " + time + ", elapsed: " + elapsed);;
        			if (radius < maxRadius) {
        				radius = speed * (elapsed / 1000)
        				context.beginPath();
        				context.arc(centre.x, centre.y, radius, 0, 2 * Math.PI, true);
        				context.closePath();
        				context.fill();
        			} else {
        				this.destroy();
        			}
        		}
        		
        		this.hasCollided = function(missile) {
        			if (alive) {
	        			var missilePosition = missile.currentPosition;
	        			var distanceToMissile = Trig.hypot((missilePosition.x - centre.x), (missilePosition.y - centre.y));
	        			console.log("Raduis: " + radius + ", Distance to missile: " + distanceToMissile);
	        			if (distanceToMissile <= radius) {
	        				return true;
	        			}
        			}
        		}
        		
        		this.destroy = function() {
        			alive = false;
        		}
        		
        		this.isAlive = function() {
        			return alive;
        		}
        	}
        	
        	
        	
        	//var boundDrawFlag = drawFlag.bind(context);
        	//drawFlag.call(context, 1, 9, "red", "green", "yellow");
        	
    
        	//context.drawGrid = drawGrid;
        	//context.drawGrid("black");
        	        	
        	//context.drawGrid("black");

  var rg = context.createRadialGradient (80, 80, 20, 120, 120, 110);
  // 2. add colors
  rg.addColorStop (0, 'yellow');
  rg.addColorStop (1, 'red');
  // 3. set the fill style to the new gradient
  context.fillStyle = rg;
  // 4. now draw some filled objects; in this case just a circle
  context.beginPath();
  context.arc (120,120,110,0,2*Math.PI,false);
  context.fill();
  context.closePath();
  
  // Shim -> get function responsible for animation.
  var requestAnimationFrame = window.requestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.msRequestAnimationFrame;
  
  //context.clearRect(0,0, context.canvas.width, context.canvas.height);
  var x = 30;
  var y = 30;
  var now = new Date();
  var millis = now.getTime();
  var count = 0;
  
  var start = new Date();
  var lastDraw = null;
  
  
  var totalDistance = 0;
  
  
  function strokeTriangle(a, b, c) {
	  context.beginPath();
	  context.moveTo(a.x, a.y);
	  context.lineTo(b.x, b.y);
	  context.lineTo(c.x, c.y);
	  context.closePath();
	  context.stroke();
  }
  
  function Mirv() {
	  var startCoord = {x: randomInteger(0, context.canvas.width), y: 0};
	  var endCoord = {x: randomInteger(0, context.canvas.width), y: context.canvas.height};
 	  
	  var rAngle = Math.atan(Math.abs(startCoord.x - endCoord.x) / context.canvas.height);	  
	  this.currentPosition = {x: startCoord.x, y: startCoord.y};
 	  var distance = 0;
 	  var speed = randomInteger(20,60);
 	  var alive = true;
 	  var burstHeight = 200;
 	  var spawned = new Date().getTime();
 	  
 	  // Determine speed & direction
 	  if (startCoord.x > endCoord.x) {
 		  speed = -speed;
 	  }
 	  
 	  
 	  this.updatePosition = function(time) {
 		 if (alive) {
 			if (this.currentPosition.y > burstHeight) {
 				 for (i = 0; i < 3; i++) {
 					 var missile = new Missile(this.currentPosition);
 					 missiles.push(missile);
 				 }				
 				 this.destroy();
 			} else {
 		 		distance = ((time - spawned) / 1000) * speed;
 	  	  		var xDisplacement = distance * Math.sin(rAngle);
 	  	  		var yDisplacement = Math.abs(distance) * Math.cos(rAngle);
 	  	 		this.currentPosition = {x: startCoord.x + xDisplacement, y: startCoord.y + yDisplacement};
 	  	  	
 	  	  		context.beginPath();
 	  	  		context.lineWidth = 3;
 	  	  		context.moveTo(startCoord.x, startCoord.y);
 	  	  		context.lineTo(this.currentPosition.x, this.currentPosition.y);
 	  	  		context.stroke();
 	  	  		context.closePath();
 			}
 		 }
 	  };
 	  
 	  this.destroy = function() {
 		  alive = false;
 	  };
  }
  
  function Missile(startCoord) {
	  var startCoord = {x: startCoord.x, y: startCoord.y};
	  var endCoord = {x: randomInteger(0, context.canvas.width), y: context.canvas.height};
	  var rAngle = Math.atan(Math.abs(startCoord.x - endCoord.x) / (startCoord.y - context.canvas.height));	  
	  this.currentPosition = {x: startCoord.x, y: startCoord.y};
 	  var distance = 0;
 	  var speed = randomInteger(20,60);
 	  var alive = true;
 	  var spawned = new Date().getTime();
 	
 	  // Determine speed & direction
 	  if (startCoord.x > endCoord.x) {
 		  speed = -speed;
 	  }
 	  
 	  
 	  this.updatePosition = function(time) {
 		  if (alive) {
 		 	distance = ((time - spawned) / 1000) * speed;
 	  	  	var xDisplacement = distance * Math.sin(rAngle);
 	  	  	var yDisplacement = Math.abs(distance) * Math.cos(rAngle);
 	  	 	this.currentPosition = {x: startCoord.x + xDisplacement, y: startCoord.y + yDisplacement};
 	  	  	
 	  	  	context.beginPath();
 	  	  	context.lineWidth = 3;
 	  	  	context.moveTo(startCoord.x, startCoord.y);
 	  	  	context.lineTo(this.currentPosition.x, this.currentPosition.y);
 	  	  	context.stroke();
 	  	  	context.closePath();
 		 }
 	  }
 	  
 	  this.destroy = function() {
 		  alive = false;
 	  }
  }
  
  
  
  var hypot = 0;
  
  
  var startTime;
  
  
  var missiles = [];
  for (i = 0; i < 15; i++) {
	  missiles.push(new Missile({x: randomInteger(0, context.canvas.width), y: 0}));
  }
  
  for (i = 0; i < 1; i++) {
	  missiles.push(new Mirv({x: randomInteger(0, context.canvas.width), y: 0}));
  }

  function detectCollissions(explosions, missiles, bases) {
	  missiles.forEach(function (missile) {
		  explosions.forEach(function (explosion) {
			  if (explosion.hasCollided(missile)) {
					 missile.destroy();
		      }
		  });
	  });
  }
  
  var stop = false;
  
  function draw(time) {
	  
	  if (!startTime) {
		  startTime = time;
	  }
	  
	  if (!lastDraw) {
		  lastDraw = time;
	  }
	  var elapsed = time - startTime;
	  
	 // hypot += 0.5;
	  
	  //var arcTan0 = Math.atan(tan0);
	 // var newX = hypot * Math.sin(arcTan0);
	 // var newY = hypot * Math.cos(arcTan0);
	 // console.log("newX:" + newX + ", newY: " + newY);
	  //strokeTriangle({x: 0, y:0}, {x: newX, y: 0}, {x: newX, y: newY});
	  
	  missiles.forEach(function(missile) {
		  missile.updatePosition(time);
	  });
	  
	  explosions.forEach(function(explosion) {
		  explosion.updatePosition(time);
	  });

	  detectCollissions(explosions, missiles);
	  
	  lastDraw = time;
      requestAnimationFrame(draw);
  }
  
  requestAnimationFrame(draw);
  
        </script>
        <footer>Footer section</footer>
    </body>
</html>
