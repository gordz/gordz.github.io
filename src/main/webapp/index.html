<!DOCTYPE html>
<html>
    <head>
        <title>Start Page</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
    	<header><h1>Header section</h1></header>
        <canvas id="canvas" width="1000" height="1000">
        </canvas>
        
        <script type="text/javascript">
        	/**
        	* Library to assist with trigonometry related functions.
        	**/
        	var Trig = {
        		toDegrees: function(radians) {
            		// 2 PI rads = 360 degrees
            		// 1 rad = 180 / PI degrees
            		return radians * (180 / Math.PI);
        		},
        		
        		toRadians: function(degrees) {
            		// 360 degrees = 2 PI radians
            		// 1 degree = PI / 180 radians
            		return degrees * (Math.PI / 180);
        		},
        		
        		hypot: function() {
        			var sumOfSquares = 0;
        			for (i = 0; i < arguments.length; i++) {
        				var square = Math.pow(arguments[i], 2);
        				sumOfSquares += square;
        			}
        			return Math.sqrt(sumOfSquares);
        		}
         	}
        	
        	function AAEmplacement(position) {
        		var coords = position;
        		var spawned = new Date();
        		var rateOfFire = 3;
        		var lastFire = spawned.getTime();
        		
        		this.updatePosition = function(time) {
        			if (time - lastFire > randomInteger(400,800)) {
        				lastFire = time;
        				var target = {x: randomInteger(0, canvas.width), y: randomInteger(200, 400)};
        				this.fireAABullet(target);
        			}
        		}
        		
        		this.fireAABullet = function(coordinate) {
            		var x = coordinate.x;
            		var y = coordinate.y;
            		
            		
        			console.log("Firing AA to position: x = " + x + ", y = " + y);
            		context.beginPath();
            		context.moveTo(500, 1000);
            		context.lineTo(x, y);
            		context.stroke();
            		
            		// Draw explosion
            		explosions.push(new Explosion({x: x, y: y}, 20));
            	}
        		
        	}
        	
        
        	var drawGrid = function(strokeStyle) {
    			const spacing = 20;
        		this.stokeStyle = strokeStyle;
        		
        		// Draw y axis.
        		this.beginPath();
        		for (i = 0; i < canvas.width / spacing; i++) {
        			// Move drawing cursor to x,y.
        			this.moveTo(0 + (i * spacing), 0);
        			// Draw line to x, y
        			this.lineTo(0 + (i * spacing), this.canvas.height);
        		}
        		
        		// Draw x axis
        		for (i = 0; i < canvas.height / spacing; i++) {
        			// Move drawing cursor to x,y.
        			this.moveTo(0, 0 + (i * spacing));
        			// Draw line to x, y
        			this.lineTo(this.canvas.width, 0 + (i * spacing));
        		}
     			this.stroke();
    			this.closePath();
        	}
        	
        	
        	function randomInteger(min, max) {
        		return min + Math.floor((max - min) * Math.random());
        	}

        	function drawHorizontalRandomJagged(context, minY, maxY, minPoints, maxPoints) {
        		var numPoints = randomInteger(minPoints, maxPoints);
        		console.log("numPoints: " + numPoints);
        		
        		// Generate random points.
        		var points = [];
            	for (i = 0; i < numPoints; i++) {
        			var x = Math.ceil(Math.random() * context.canvas.width);
        			var y = randomInteger(minY, maxY);
        			points.push({ x: x, y: y});
        		}
            	
            	// Sort by x co-ordinate.
        		points.sort(function(a, b) { 
        			return a.x - b.x;
        		});
          		
          		// Start at x = 0	
          		context.beginPath();
    			context.moveTo(0, randomInteger(minY, maxY));
    			points.forEach(function(point) {
    				context.lineTo(Number.toInteger(point.x), Number.toInteger(point.y));
    			});
    			// Finish at x = canvas width.
        		context.lineTo(context.canvas.width, randomInteger(minY, maxY));
        		
        		// Close to form polygon.
				context.lineTo(context.canvas.width, context.canvas.height);
        		context.lineTo(0, context.canvas.height);
        		context.closePath();
        		
        		// Fill with a gradient.
        		var gradient = context.createLinearGradient(0, minY, 0, context.canvas.height);
        		gradient.addColorStop(0, '#009900')
        		gradient.addColorStop(0.25, '#336600');
        		gradient.addColorStop(0.50, '#7A5229');
        		gradient.addColorStop(0.75,'#493119');
   				context.fillStyle = gradient;
        		context.fill();
        	}
        	
        	function drawSky(context) {
        		context.fillStyle = "#0099FF";	//sky blue.
        		context.fillRect(0, 0, context.canvas.width, context.canvas.height);
        	}
        	
        	function drawGround(context) {
        		drawHorizontalRandomJagged(context, 600, 940, 40, 50);
        	}
        	
        	
        	var drawRandomJagged = function(minX, minY, maxX, maxY) {
        		var points = Math.floor(10 + (Math.random() * 10));
        		
        		//this.moveTo(0, 300);
        		var randomPoints = [];
        		for (i = 0; i < points; i++) {
        			var randX = minX + Math.floor(((maxX - minX) * Math.random()));
        			var randY = minY + Math.floor(((maxY - minY) * Math.random()));
        			randomPoints.push({x: randX, y: randY});
        		}    		
        	}
   
        	// Draw a 3 colour flag.
        	var drawFlag = function(x, y, colour1, colour2, colour3) {
        		this.fillStyle = colour1;
        		this.fillRect(x, y, 20, 80);
        		
        		this.fillStyle = colour2;
        		this.fillRect(x + 20, y, 20, 80);
        		
        		this.fillStyle = colour3;
        		this.fillRect(x + 40, y, 20, 80);
        	}
        	
        	

        	var canvas = document.getElementById("canvas");
        	
        	// Get a CanvasRenderingContext2D.
        	var context = canvas.getContext("2d");

        	
        	// Draw a rectangle.
        	//context.fillStyle = "black";
        	// X, Y, width, height
        	//context.fillRect (1,9,400,400);
        	canvas.onclick = function(event) {
        		fireBullet(event);
        	}
        	
        	
        	var explosions = [];
        	
        	function fireBullet(event) {
        		var x = event.clientX - canvas.offsetLeft;
        		var y = event.clientY - canvas.offsetTop;
        		
        	    y += document.documentElement.scrollTop;
        	    
        		context.beginPath();
        		context.moveTo(0, 400);
        		context.lineTo(x, y);
        		context.stroke();
        		
        		// Draw explosion
        		explosions.push(new Explosion({x: x, y: y}, 60));
        	}

        	function Explosion(centre, maxRadius) {
        		var speed = 50;
        		this.maxRadius = maxRadius;
        		var centre = centre;
        		var startTime = new Date().getTime();
        		var radius = 0;
        		var alive = true;
        		
        		this.updatePosition = function(time) {
        			        			
        			var elapsed = time - startTime;
        			//console.log("Time: " + time + ", elapsed: " + elapsed);;
        			if (radius < maxRadius) {
        				radius = speed * (elapsed / 1000)
        				context.globalCompositeOperation = "source-over";
        				
        				var rg = context.createRadialGradient (centre.x, centre.y, 10, centre.x, centre.y, maxRadius);
        				rg.addColorStop (0, 'yellow');
        				rg.addColorStop (1, 'red');
        				context.fillStyle = rg;

        				context.beginPath();
        				context.arc(centre.x, centre.y, radius, 0, 2 * Math.PI, true);
        				context.closePath();
        				context.fill();
        			} else {
        				this.destroy();
        			}
        		}
        		
        		this.hasCollided = function(missile) {
        			if (alive) {
	        			var missilePosition = missile.currentPosition;
	        			var distanceToMissile = Trig.hypot((missilePosition.x - centre.x), (missilePosition.y - centre.y));
	        			console.log("Raduis: " + radius + ", Distance to missile: " + distanceToMissile);
	        			if (distanceToMissile <= radius) {
	        				return true;
	        			}
        			}
        		}
        		
        		this.destroy = function() {
        			alive = false;
        		}
        		
        		this.isAlive = function() {
        			return alive;
        		}
        	}


        	
        	
  function drawSun() {
	  var rg = context.createRadialGradient (80, 80, 20, 120, 120, 110);
	  // 2. add colors
	  rg.addColorStop (0, 'yellow');
	  rg.addColorStop (1, 'red');
	  // 3. set the fill style to the new gradient
	  context.fillStyle = rg;
	  // 4. now draw some filled objects; in this case just a circle
	  context.beginPath();
	  context.arc (120,120,110,0,2*Math.PI,false);
	  context.fill();
	  context.closePath();
  }      	

  
  // Shim -> get function responsible for animation.
  var requestAnimationFrame = window.requestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.msRequestAnimationFrame;
  
  //context.clearRect(0,0, context.canvas.width, context.canvas.height);
  var x = 30;
  var y = 30;
  var now = new Date();
  var millis = now.getTime();
  var count = 0;
  
  var start = new Date();
  var lastDraw = null;
  
  
  var totalDistance = 0;
  
  
  function strokeTriangle(a, b, c) {
	  context.beginPath();
	  context.moveTo(a.x, a.y);
	  context.lineTo(b.x, b.y);
	  context.lineTo(c.x, c.y);
	  context.closePath();
	  context.stroke();
  }
  
  function Mirv() {
	  var startCoord = {x: randomInteger(0, context.canvas.width), y: 0};
	  var endCoord = {x: randomInteger(0, context.canvas.width), y: context.canvas.height};
 	  
	  var rAngle = Math.atan(Math.abs(startCoord.x - endCoord.x) / context.canvas.height);	  
	  this.currentPosition = {x: startCoord.x, y: startCoord.y};
 	  var distance = 0;
 	  var speed = randomInteger(20,60);
 	  var alive = true;
 	  var burstHeight = 200;
 	  var spawned = new Date().getTime();
 	  
 	  // Determine speed & direction
 	  if (startCoord.x > endCoord.x) {
 		  speed = -speed;
 	  }
 	  
 	  
 	  this.updatePosition = function(time) {
 		 if (alive) {
 			if (this.currentPosition.y > burstHeight) {
 				 for (i = 0; i < 3; i++) {
 					 var missile = new Missile(this.currentPosition);
 					 missiles.push(missile);
 				 }				
 				 this.destroy();
 			} else {
 		 		distance = ((time - spawned) / 1000) * speed;
 	  	  		var xDisplacement = distance * Math.sin(rAngle);
 	  	  		var yDisplacement = Math.abs(distance) * Math.cos(rAngle);
 	  	 		this.currentPosition = {x: startCoord.x + xDisplacement, y: startCoord.y + yDisplacement};
 	  	  	
 	  	  		context.beginPath();
 	  	  		context.lineWidth = 3;
 	  	  		context.moveTo(startCoord.x, startCoord.y);
 	  	  		context.lineTo(this.currentPosition.x, this.currentPosition.y);
 	  	  		context.stroke();
 	  	  		context.closePath();
 			}
 		 }
 	  };
 	  
 	  this.destroy = function() {
 		  alive = false;
 	  };
  }
  
  function Emp(startCoord) {
	  
	  var spawned = new Date();
	  var speed = 700;
	  var alive = true;
	  var centre = startCoord;
	  var radius = 0;
	  
	  this.updatePosition = function(time) {
		  if (alive) {
		  	this.radius = speed * ((time - spawned.getTime()) / 1000);
		  	context.beginPath();
		  	context.arc(startCoord.x, startCoord.y, this.radius, 0, 2 * Math.PI, true);
		  	context.stroke();
		  }
		  
	  }
	  
	  this.hasCollided = function(missile) {
	  	if (alive) {
        		var missilePosition = missile.currentPosition;
        		var distanceToMissile = Trig.hypot((missilePosition.x - centre.x), (missilePosition.y - centre.y));
        		if (distanceToMissile <= this.radius) {
        			return true;
        		}
	  	}
	}
  	}
  
  function Missile(startCoord) {
	  var startCoord = {x: startCoord.x, y: startCoord.y};
	  var endCoord = {x: randomInteger(0, context.canvas.width), y: context.canvas.height};
	  var rAngle = Math.atan(Math.abs(startCoord.x - endCoord.x) / (startCoord.y - context.canvas.height));	  
	  this.currentPosition = {x: startCoord.x, y: startCoord.y};
 	  var distance = 0;
 	  var speed = randomInteger(50,90);
 	  var alive = true;
 	  var spawned = new Date().getTime();
 	
 	  // Determine speed & direction
 	  if (startCoord.x > endCoord.x) {
 		  speed = -speed;
 	  }
 	  
 	  
 	  this.updatePosition = function(time) {
 		  if (alive) {
 		 	distance = ((time - spawned) / 1000) * speed;
 	  	  	var xDisplacement = distance * Math.sin(rAngle);
 	  	  	var yDisplacement = Math.abs(distance) * Math.cos(rAngle);
 	  	 	this.currentPosition = {x: startCoord.x + xDisplacement, y: startCoord.y + yDisplacement};
 	  	  	
 	  	  	context.beginPath();
 	  	  	context.lineWidth = 3;
 	  	  	context.moveTo(startCoord.x, startCoord.y);
 	  	  	context.lineTo(this.currentPosition.x, this.currentPosition.y);
 	  	  	context.stroke();
 	  	  	context.closePath();
 		 }
 	  }
 	  
 	  this.destroy = function() {
 		  alive = false;
 	  }
  }
  
  
 
/*  var emps = []
  for (i = 0; i < 1; i++) {
	  emps.push(new Emp({x: 500, y: 700}));
  }
  */
  var aaEmplacements = [];
  for (i = 0; i < 2 ; i++) {
	  aaEmplacements.push(new AAEmplacement({x: 300, y:800}));
  }
  
  
  var missiles = [];
  for (i = 0; i < 15; i++) {
	  missiles.push(new Missile({x: randomInteger(0, context.canvas.width), y: 0}));
  }
  
  for (i = 0; i < 1; i++) {
	  missiles.push(new Mirv({x: randomInteger(0, context.canvas.width), y: 0}));
  }

  // TODO implement with underscore.js.
  /*
  function filter(array, predicate) {
	  var result = [];
	  array.forEach(function(element) {

	  });
  }
  */
  
  
  function detectCollissions(explosions, missiles, bases) {
	  missiles.forEach(function (missile) {
		  explosions.forEach(function (explosion) {
			  if (explosion.hasCollided(missile)) {
					 missile.destroy();
		      }
		  });
		  /*
		  emps.forEach(function(emp) {
			 if (emp.hasCollided(missile)) {
				 missile.destroy();
			 } 
		  });
		  */
	  });
  }
  
  var startTime;
  function draw(time) {
	  
	  context.clearRect(0, 0, context.canvas.width, context.canvas.height);
	  drawBackground();
	  
	  if (!startTime) {
		  startTime = time;
	  }
	  
	  missiles.forEach(function(missile) {
		  missile.updatePosition(time);
	  });
	  
	  explosions.forEach(function(explosion) {
		  explosion.updatePosition(time);
	  });
	  
	  aaEmplacements.forEach(function(aaEmplacement) {
		  aaEmplacement.updatePosition(time);
	  })

	  /*
	  emps.forEach(function(emp) {
		emp.updatePosition(time);  
	  });
	  */
	  
	  detectCollissions(explosions, missiles);
	  
      requestAnimationFrame(draw);
  }
  
  requestAnimationFrame(draw);
  
 
 var background;
 
 function drawBackground() {
	 if (background != null || background != undefined) {
		 context.putImageData(background, 0, 0, context.canvas.width, context.canvas.height);
	 } else {
		 drawSky(context);
		 drawGround(context);
		 drawSun();
	 	 background = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
	 }

	 	 
 }

        </script>
        <footer>Footer section</footer>
    </body>
</html>
